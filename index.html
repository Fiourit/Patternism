<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patternism</title>
    <style>
        body {
            text-align: center;
            font-family: 'Poppins', sans-serif;
            background: url('https://images.unsplash.com/photo-1507525428034-b723cf961d3e?ixlib=rb-4.0.3&auto=format&fit=crop&w=1350&q=80') no-repeat center center fixed;
            background-size: cover;
            background-color: rgba(255, 255, 255, 0.85);
            color: #333;
            margin: 0;
            padding: 10px;
            min-height: 100vh;
            position: relative;
            display: block; /* Ensure body is a block to allow natural flow */
        }
        .header {
            position: absolute;
            top: 10px;
            left: 10px;
            text-align: left;
            font-size: clamp(14px, 3vw, 20px);
            font-weight: 600;
            color: #333;
            text-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        .logo {
            display: block;
            width: clamp(100px, 13.3vw, 133px);
            height: auto;
            margin-top: 5px;
        }
        .tagline {
            display: block;
            font-size: clamp(12px, 2.5vw, 16px);
            font-weight: 400;
            color: #666;
            text-shadow: 0 1px 2px rgba(0,0,0,0.2);
            margin-top: 5px;
        }
        .container {
            display: flex;
            flex-direction: row;
            gap: 20px;
            max-width: 1200px;
            width: 100%;
            align-items: center;
            flex-wrap: wrap;
            margin: 120px auto 20px; /* Add margin to ensure space below header and above instructions */
        }
        .left-panel {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            width: 180px;
            min-width: 150px;
        }
        .status {
            font-size: clamp(18px, 5vw, 24px);
            font-weight: 600;
            text-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
            margin-bottom: 5px;
        }
        .timers {
            display: flex;
            flex-direction: column;
            gap: 8px;
            width: 100%;
        }
        .timer {
            font-size: clamp(16px, 4vw, 20px);
            font-weight: 500;
            padding: 8px 12px;
            border-radius: 8px;
            text-align: center;
            width: 100%;
            box-sizing: border-box;
            color: #fff;
        }
        .timer.red {
            background: linear-gradient(145deg, #cc6666, #993333);
            box-shadow: 0 3px 6px rgba(204,102,102,0.4);
        }
        .timer.green {
            background: linear-gradient(145deg, #66cc66, #339933);
            box-shadow: 0 3px 6px rgba(102,204,102,0.4);
        }
        .board {
            position: relative;
            width: min(600px, 90vw);
            height: min(600px, 90vw);
            background: radial-gradient(circle, rgba(255,255,255,0.2), rgba(0,0,0,0.1));
            border-radius: 50%;
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
            margin: 0 auto;
        }
        .circle {
            position: absolute;
            border-radius: 50%;
            border: 3px solid #fff;
            transition: transform 0.6s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            background: linear-gradient(45deg, rgba(255,255,255,0.1), rgba(0,0,0,0.05));
            transform-origin: center;
        }
        .circle.A { width: 92%; height: 92%; top: 4%; left: 4%; }
        .circle.B { width: 73%; height: 73%; top: 14%; left: 14%; }
        .circle.C { width: 54.5%; height: 54.5%; top: 23.5%; left: 23.5%; }
        .house {
            position: absolute;
            width: clamp(25px, 6vw, 35px);
            height: clamp(25px, 6vw, 35px);
            border-radius: 50%;
            background-color: rgba(255,255,255,0.95);
            border: 2px solid #333;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: clamp(12px, 3vw, 16px);
            font-weight: 700;
            color: #222;
            transition: all 0.3s ease;
            opacity: 0.85;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .house:hover {
            transform: scale(1.15) rotate(5deg);
            opacity: 1;
            box-shadow: 0 5px 15px rgba(0,0,0,0.4);
        }
        .house.claimed {
            animation: pulse 0.5s ease-in-out;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: auto;
            min-width: 70px;
        }
        .arrow {
            width: clamp(50px, 15vw, 70px);
            height: clamp(50px, 15vw, 70px);
            background: linear-gradient(145deg, #facc15, #ea580c);
            border: none;
            border-radius: 12px;
            text-align: center;
            line-height: clamp(50px, 15vw, 70px);
            font-size: clamp(24px, 6vw, 32px);
            cursor: pointer;
            color: #fff;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 3px 3px 8px rgba(0,0,0,0.3), -3px -3px 8px rgba(255,255,255,0.1);
        }
        .arrow:hover:not(.disabled) {
            transform: translateY(-3px);
            box-shadow: 5px 5px 12px rgba(0,0,0,0.4), -5px -5px 12px rgba(255,255,255,0.2);
            background: linear-gradient(145deg, #fde047, #f97316);
        }
        .arrow.disabled {
            background: #999;
            cursor: not-allowed;
            box-shadow: inset 2px 2px 5px rgba(0,0,0,0.3);
            transform: translateY(0);
        }
        .reset-btn {
            padding: 10px 20px;
            font-size: clamp(14px, 4vw, 18px);
            background: linear-gradient(90deg, #ef4444, #b91c1c);
            color: #fff;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(239,68,68,0.4);
            width: 100%;
            box-sizing: border-box;
        }
        .reset-btn:hover {
            transform: scale(1.05);
            background: linear-gradient(90deg, #f87171, #dc2626);
            box-shadow: 0 8px 20px rgba(239,68,68,0.6);
        }
        .computer-toggle {
            padding: 8px 16px;
            font-size: clamp(12px, 3vw, 16px);
            background: linear-gradient(90deg, #4d4dff, #1c1cb9);
            color: #fff;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(77,77,255,0.4);
            width: 100%;
            box-sizing: border-box;
        }
        .computer-toggle:hover {
            transform: scale(1.05);
            background: linear-gradient(90deg, #7171f8, #2626dc);
            box-shadow: 0 8px 20px rgba(77,77,255,0.6);
        }
        .dice-container {
            position: absolute;
            top: 10px;
            right: 10px;
            text-align: center;
        }
        .dice-btn {
            width: 50px;
            height: 50px;
            background: linear-gradient(145deg, #fff, #ccc);
            border: 2px solid #333;
            border-radius: 8px;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        .dice-btn:hover:not(.disabled) {
            transform: scale(1.1);
            background: linear-gradient(145deg, #f0f0f0, #bbb);
        }
        .dice-btn.disabled {
            background: #999;
            cursor: not-allowed;
            box-shadow: inset 2px 2px 5px rgba(0,0,0,0.3);
            transform: none;
        }
        .pattern-display {
            margin-top: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        .pattern-number {
            font-size: 16px;
            font-weight: 600;
            color: #333;
        }
        .pattern-image {
            width: 100px;
            height: 100px;
            margin-top: 5px;
            display: block;
        }
        .instructions {
            text-align: left;
            max-width: 800px;
            margin: 20px auto;
            padding: 20px;
            color: #333;
            text-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }
        .instructions h2 {
            font-size: clamp(20px, 5vw, 28px);
            font-weight: 700;
            margin-bottom: 15px;
        }
        .instructions p {
            font-size: clamp(14px, 3vw, 18px);
            line-height: 1.5;
            margin: 10px 0;
        }
        .instructions img {
            width: 60px;
            height: 60px;
            vertical-align: middle;
            margin: 0 5px;
        }
        @media (max-width: 900px) {
            .container {
                flex-direction: column;
                align-items: center;
                gap: 15px;
            }
            .left-panel {
                width: 100%;
                max-width: 250px;
                order: 1;
            }
            .board {
                order: 2;
            }
            .controls {
                width: 100%;
                max-width: 250px;
                flex-direction: row;
                justify-content: center;
                flex-wrap: wrap;
                order: 3;
            }
            .arrow {
                margin: 5px;
            }
            .dice-container {
                top: 120px;
                right: 10px;
            }
        }
        @media (max-width: 400px) {
            body {
                padding: 5px;
            }
            .container {
                gap: 10px;
            }
            .status {
                margin-bottom: 0;
            }
            .timers {
                gap: 5px;
            }
            .header {
                top: 5px;
                left: 5px;
            }
            .dice-container {
                top: 100px;
                right: 5px;
            }
            .dice-btn {
                width: 40px;
                height: 40px;
                font-size: 20px;
            }
            .pattern-image {
                width: 80px;
                height: 80px;
            }
            .logo {
                width: clamp(80px, 13.3vw, 107px);
            }
            .instructions img {
                width: 40px;
                height: 40px;
            }
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body>
    <div class="header">
        FiouriT mindstyle
        <img class="logo" src="Patternism - Logo.jpg" alt="Patternism Logo">
        <span class="tagline">Logic in Motion...</span>
    </div>
    <div class="dice-container">
        <button class="dice-btn" id="diceButton">üé≤</button>
        <div class="pattern-display" id="patternDisplay">
            <div class="pattern-number" id="patternNumber">Roll the dice!</div>
            <img class="pattern-image" id="patternImage" src="" alt="Pattern">
        </div>
    </div>
    <div class="container">
        <div class="left-panel">
            <div class="status" id="statusText">Red's Turn</div>
            <div class="timers">
                <div class="timer red" id="redTimer">Red: 30:00</div>
                <div class="timer green" id="greenTimer">Green: 30:00</div>
            </div>
            <button class="reset-btn" id="resetButton">Reset Game</button>
            <button class="computer-toggle" id="computerToggle">Computer Mode: Off</button>
        </div>
        <div class="board" id="gameBoard">
            <div class="circle A" id="circleA"></div>
            <div class="circle B" id="circleB"></div>
            <div class="circle C" id="circleC"></div>
        </div>
        <div class="controls">
            <div class="arrow" id="arrowRight">‚û°Ô∏è</div>
            <div class="arrow" id="arrowLeft">‚¨ÖÔ∏è</div>
            <div class="arrow" id="arrowUp">‚¨ÜÔ∏è</div>
            <div class="arrow" id="arrowDown">‚¨áÔ∏è</div>
        </div>
    </div>

    <script>
        document.addEventListener("DOMContentLoaded", function () {
            const rotations = { A: 0, B: 0, C: 0 };
            let currentPlayer = "red";
            const statusText = document.getElementById("statusText");
            let awaitingRotation = null;
            const initialTime = 30 * 60 * 1000;
            let timers = { red: initialTime, green: initialTime };
            let timerInterval = null;
            let timerStarted = { red: false, green: false };
            let computerMode = false;
            let selectedPattern = null;
            let gameStarted = false;

            const patternImages = {
                1: "pattern1.png",
                2: "pattern2.png",
                3: "pattern3.png",
                4: "pattern4.png",
                5: "pattern5.png",
                6: "pattern6.png"
            };

            const targetPatterns = {
                1: { A: [0, 1, 2], B: [1], C: [0, 1, 2] }, // H shape
                2: { A: [0], B: [0], C: [0] }, // I shape
                3: { A: [0], B: [1, 17], C: [2, 16] }, // Arrow toward center
                4: { A: [2, 16], B: [1, 17], C: [0] }, // Arrow away from center
                5: { A: [0, 5], B: [0, 5], C: [0, 5] }, // Straight line of 6
                6: { A: [0, 6, 12], B: [0, 6, 12], C: [0, 6, 12] } // Mercedes-Benz logo
            };

            function rollDice() {
                if (!gameStarted) {
                    selectedPattern = Math.floor(Math.random() * 6) + 1;
                    updatePatternDisplay();
                    updateStatusText();
                }
            }

            function updatePatternDisplay() {
                const patternNumber = document.getElementById("patternNumber");
                const patternImage = document.getElementById("patternImage");
                patternNumber.textContent = `Pattern ${selectedPattern}`;
                patternImage.src = patternImages[selectedPattern];
                patternImage.alt = `Pattern ${selectedPattern}`;
            }

            function updateStatusText() {
                if (awaitingRotation) {
                    statusText.textContent = `${currentPlayer === "red" ? "Red" : "Green"}, Rotate ${awaitingRotation === "B" ? "Up/Down" : "Left/Right"}`;
                } else if (selectedPattern) {
                    statusText.textContent = `${currentPlayer === "red" ? "Red" : "Green"}'s Turn (Pattern ${selectedPattern})`;
                }
                statusText.style.color = currentPlayer === "red" ? "#ff4d4d" : "#4dff4d";
            }

            function updateTimerDisplay() {
                const redTime = Math.max(0, timers.red);
                const greenTime = Math.max(0, timers.green);
                document.getElementById("redTimer").textContent = `Red: ${Math.floor(redTime / 60000)}:${String(Math.floor((redTime % 60000) / 1000)).padStart(2, "0")}`;
                document.getElementById("greenTimer").textContent = `Green: ${Math.floor(greenTime / 60000)}:${String(Math.floor((greenTime % 60000) / 1000)).padStart(2, "0")}`;
                if (timers[currentPlayer] <= 0) {
                    clearInterval(timerInterval);
                    statusText.textContent = `${currentPlayer === "red" ? "Green" : "Red"} Wins! Time's Up!`;
                    awaitingRotation = "gameOver";
                    toggleArrows(null);
                }
            }

            function startTimer(player) {
                if (timerInterval) clearInterval(timerInterval);
                timerInterval = setInterval(() => {
                    if (timers[player] > 0) {
                        timers[player] -= 1000;
                        updateTimerDisplay();
                    }
                }, 1000);
            }

            function stopTimer() {
                clearInterval(timerInterval);
            }

            function createHouses() {
                const circles = { A: "circleA", B: "circleB", C: "circleC" };
                const board = document.getElementById("gameBoard");
                const boardSize = board.offsetWidth || 600;
                const positions = {
                    A: boardSize * 0.46,
                    B: boardSize * 0.365,
                    C: boardSize * 0.2725
                };
                const angleStep = 360 / 18;
                Object.entries(circles).forEach(([circle, id]) => {
                    const parent = document.getElementById(id);
                    for (let i = 0; i < 18; i++) {
                        let house = document.createElement("div");
                        house.classList.add("house");
                        let angle = i * angleStep;
                        let radius = positions[circle];
                        let x = Math.cos(angle * Math.PI / 180) * radius;
                        let y = Math.sin(angle * Math.PI / 180) * radius;
                        let houseSize = Math.min(Math.max(25, window.innerWidth * 0.06), 35);
                        house.style.left = `calc(50% + ${x}px - ${houseSize / 2}px)`;
                        house.style.top = `calc(50% + ${y}px - ${houseSize / 2}px)`;
                        house.dataset.circle = circle;
                        house.dataset.index = i;
                        house.textContent = i + 1;
                        house.addEventListener("click", function () {
                            if (!house.style.backgroundColor && !awaitingRotation && timers[currentPlayer] > 0) {
                                claimHouse(house, circle);
                            }
                        });
                        parent.appendChild(house);
                    }
                });
            }

            function claimHouse(house, circle) {
                house.style.backgroundColor = currentPlayer === "red" ? "#ff4d4d" : "#4dff4d";
                house.style.opacity = "1";
                house.classList.add("claimed");
                gameStarted = true;
                document.getElementById("diceButton").classList.add("disabled");
                if (circle === "A") {
                    stopTimer();
                    if (checkWin(currentPlayer)) return;
                    switchPlayer();
                } else {
                    awaitingRotation = circle;
                    updateStatusText();
                    toggleArrows(circle);
                    if (computerMode && currentPlayer === "green") {
                        setTimeout(computerRotate, 1000);
                    }
                }
            }

            function switchPlayer() {
                currentPlayer = currentPlayer === "red" ? "green" : "red";
                if (!timerStarted[currentPlayer]) {
                    timerStarted[currentPlayer] = true;
                    startTimer(currentPlayer);
                } else {
                    startTimer(currentPlayer);
                }
                awaitingRotation = null;
                toggleArrows(null);
                updateStatusText();
                if (computerMode && currentPlayer === "green" && !awaitingRotation) {
                    setTimeout(computerMove, 1000);
                }
            }

            function evaluateMoveScore(house) {
                const circle = house.dataset.circle;
                const index = parseInt(house.dataset.index);
                const adjustedIndex = getAdjustedIndex(circle, index);
                const target = targetPatterns[selectedPattern][circle];
                let score = target.includes(adjustedIndex) ? 2 : 0;

                // Bonus for proximity to existing claimed houses
                const claimed = Array.from(document.querySelectorAll(".house"))
                    .filter(h => h.style.backgroundColor === "#4dff4d")
                    .map(h => ({
                        circle: h.dataset.circle,
                        index: getAdjustedIndex(h.dataset.circle, parseInt(h.dataset.index))
                    }));
                claimed.forEach(c => {
                    if (c.circle === circle && Math.abs(c.index - adjustedIndex) <= 2) {
                        score += 1;
                    }
                });

                return score;
            }

            function computerMove() {
                const houses = Array.from(document.querySelectorAll(".house")).filter(h => !h.style.backgroundColor);
                if (houses.length === 0) return;

                // Evaluate all possible moves and pick the best
                let bestHouse = null;
                let bestScore = -1;

                houses.forEach(house => {
                    const score = evaluateMoveScore(house);
                    if (score > bestScore) {
                        bestScore = score;
                        bestHouse = house;
                    }
                });

                if (bestHouse) {
                    claimHouse(bestHouse, bestHouse.dataset.circle);
                } else {
                    // Fallback to random if no scoring move found (shouldn't happen)
                    const house = houses[Math.floor(Math.random() * houses.length)];
                    claimHouse(house, house.dataset.circle);
                }
            }

            function computerRotate() {
                if (!awaitingRotation) return;

                const claimedHouses = Array.from(document.querySelectorAll(".house"))
                    .filter(h => h.style.backgroundColor === "#4dff4d")
                    .map(h => ({
                        circle: h.dataset.circle,
                        index: getAdjustedIndex(h.dataset.circle, parseInt(h.dataset.index))
                    }));
                const target = targetPatterns[selectedPattern];

                // Calculate best rotation to align with target pattern
                let bestRotation = 0;
                let bestScore = -1;

                const rotationOptions = awaitingRotation === "B" ? [-40, 0, 40] : [-20, 0, 20];
                rotationOptions.forEach(rotation => {
                    let tempRotations = { ...rotations };
                    if (awaitingRotation === "B") {
                        tempRotations.B += rotation;
                        tempRotations.C += rotation;
                    } else {
                        tempRotations.C += rotation;
                    }

                    let score = 0;
                    claimedHouses.forEach(house => {
                        const adjustedIndex = getAdjustedIndex(house.circle, parseInt(house.dataset?.index || house.index), tempRotations[house.circle]);
                        if (target[house.circle].includes(adjustedIndex)) {
                            score += 1;
                        }
                    });

                    if (score > bestScore) {
                        bestScore = score;
                        bestRotation = rotation;
                    }
                });

                // Apply the best rotation
                if (awaitingRotation === "B") {
                    rotateCircle("B", bestRotation);
                    rotateCircle("C", bestRotation);
                } else if (awaitingRotation === "C") {
                    rotateCircle("C", bestRotation);
                }

                awaitingRotation = null;
                stopTimer();
                if (checkWin(currentPlayer)) return;
                switchPlayer();
            }

            function rotateCircle(circle, degrees) {
                rotations[circle] += degrees;
                document.getElementById(`circle${circle}`).style.transform = `rotate(${rotations[circle]}deg)`;
            }

            function toggleArrows(circle) {
                const left = document.getElementById("arrowLeft");
                const right = document.getElementById("arrowRight");
                const up = document.getElementById("arrowUp");
                const down = document.getElementById("arrowDown");
                if (circle === "B") {
                    left.classList.add("disabled");
                    right.classList.add("disabled");
                    up.classList.remove("disabled");
                    down.classList.remove("disabled");
                } else if (circle === "C") {
                    left.classList.remove("disabled");
                    right.classList.remove("disabled");
                    up.classList.add("disabled");
                    down.classList.add("disabled");
                } else {
                    left.classList.add("disabled");
                    right.classList.add("disabled");
                    up.classList.add("disabled");
                    down.classList.add("disabled");
                }
            }

            function getAdjustedIndex(circle, index, tempRotation = rotations[circle]) {
                const rotation = tempRotation;
                const step = 360 / 18;
                let adjusted = (index + Math.round(rotation / step)) % 18;
                return adjusted < 0 ? adjusted + 18 : adjusted;
            }

            function checkWin(player) {
                const houses = Array.from(document.querySelectorAll(".house")).filter(h => 
                    h.style.backgroundColor === (player === "red" ? "#ff4d4d" : "#4dff4d")
                );
                const positions = houses.map(h => ({
                    circle: h.dataset.circle,
                    index: getAdjustedIndex(h.dataset.circle, parseInt(h.dataset.index))
                }));

                const checkPattern = {
                    1: () => { // H shape
                        for (let i = 0; i < 18; i++) {
                            if (positions.some(p => p.circle === "A" && p.index === i) &&
                                positions.some(p => p.circle === "A" && p.index === (i + 1) % 18) &&
                                positions.some(p => p.circle === "A" && p.index === (i + 2) % 18) &&
                                positions.some(p => p.circle === "B" && p.index === (i + 1) % 18) &&
                                positions.some(p => p.circle === "C" && p.index === i) &&
                                positions.some(p => p.circle === "C" && p.index === (i + 1) % 18) &&
                                positions.some(p => p.circle === "C" && p.index === (i + 2) % 18)) {
                                return true;
                            }
                        }
                        return false;
                    },
                    2: () => { // I shape
                        for (let i = 0; i < 18; i++) {
                            if (positions.some(p => p.circle === "A" && p.index === i) &&
                                positions.some(p => p.circle === "B" && p.index === i) &&
                                positions.some(p => p.circle === "C" && p.index === i)) {
                                return true;
                            }
                        }
                        return false;
                    },
                    3: () => { // Arrow toward center
                        for (let i = 0; i < 18; i++) {
                            if (positions.some(p => p.circle === "A" && p.index === i) &&
                                positions.some(p => p.circle === "B" && p.index === (i + 1) % 18) &&
                                positions.some(p => p.circle === "C" && p.index === (i + 2) % 18) &&
                                positions.some(p => p.circle === "B" && p.index === (i - 1 + 18) % 18) &&
                                positions.some(p => p.circle === "C" && p.index === (i - 2 + 18) % 18)) {
                                return true;
                            }
                        }
                        return false;
                    },
                    4: () => { // Arrow away from center
                        for (let i = 0; i < 18; i++) {
                            if (positions.some(p => p.circle === "C" && p.index === i) &&
                                positions.some(p => p.circle === "B" && p.index === (i + 1) % 18) &&
                                positions.some(p => p.circle === "A" && p.index === (i + 2) % 18) &&
                                positions.some(p => p.circle === "B" && p.index === (i - 1 + 18) % 18) &&
                                positions.some(p => p.circle === "A" && p.index === (i - 2 + 18) % 18)) {
                                return true;
                            }
                        }
                        return false;
                    },
                    5: () => { // Straight line of 6
                        for (let i = 0; i < 13; i++) {
                            if (positions.some(p => p.circle === "A" && p.index === i) &&
                                positions.some(p => p.circle === "B" && p.index === i) &&
                                positions.some(p => p.circle === "C" && p.index === i) &&
                                positions.some(p => p.circle === "A" && p.index === (i + 5) % 18) &&
                                positions.some(p => p.circle === "B" && p.index === (i + 5) % 18) &&
                                positions.some(p => p.circle === "C" && p.index === (i + 5) % 18)) {
                                return true;
                            }
                        }
                        return false;
                    },
                    6: () => { // Mercedes-Benz logo
                        for (let i = 0; i < 18; i++) {
                            if (positions.some(p => p.circle === "A" && p.index === i) &&
                                positions.some(p => p.circle === "B" && p.index === i) &&
                                positions.some(p => p.circle === "C" && p.index === i) &&
                                positions.some(p => p.circle === "A" && p.index === (i + 6) % 18) &&
                                positions.some(p => p.circle === "B" && p.index === (i + 6) % 18) &&
                                positions.some(p => p.circle === "C" && p.index === (i + 6) % 18) &&
                                positions.some(p => p.circle === "A" && p.index === (i + 12) % 18) &&
                                positions.some(p => p.circle === "B" && p.index === (i + 12) % 18) &&
                                positions.some(p => p.circle === "C" && p.index === (i + 12) % 18)) {
                                return true;
                            }
                        }
                        return false;
                    }
                };

                if (checkPattern[selectedPattern]()) {
                    stopTimer();
                    statusText.textContent = `${player === "red" ? "Red" : "Green"} Wins! Pattern ${selectedPattern} Achieved!`;
                    awaitingRotation = "gameOver";
                    toggleArrows(null);
                    return true;
                }
                return false;
            }

            document.getElementById("diceButton").addEventListener("click", function() {
                if (!gameStarted && (!awaitingRotation || awaitingRotation !== "gameOver")) {
                    rollDice();
                }
            });

            document.getElementById("arrowLeft").addEventListener("click", function() {
                if (awaitingRotation === "C" && !this.classList.contains("disabled")) {
                    rotateCircle("C", -20);
                    awaitingRotation = null;
                    stopTimer();
                    if (checkWin(currentPlayer)) return;
                    switchPlayer();
                }
            });

            document.getElementById("arrowRight").addEventListener("click", function() {
                if (awaitingRotation === "C" && !this.classList.contains("disabled")) {
                    rotateCircle("C", 20);
                    awaitingRotation = null;
                    stopTimer();
                    if (checkWin(currentPlayer)) return;
                    switchPlayer();
                }
            });

            document.getElementById("arrowUp").addEventListener("click", function() {
                if (awaitingRotation === "B" && !this.classList.contains("disabled")) {
                    rotateCircle("B", -40);
                    rotateCircle("C", -40);
                    awaitingRotation = null;
                    stopTimer();
                    if (checkWin(currentPlayer)) return;
                    switchPlayer();
                }
            });

            document.getElementById("arrowDown").addEventListener("click", function() {
                if (awaitingRotation === "B" && !this.classList.contains("disabled")) {
                    rotateCircle("B", 40);
                    rotateCircle("C", 40);
                    awaitingRotation = null;
                    stopTimer();
                    if (checkWin(currentPlayer)) return;
                    switchPlayer();
                }
            });

            document.getElementById("resetButton").addEventListener("click", function() {
                document.querySelectorAll(".house").forEach(house => {
                    house.style.backgroundColor = "";
                    house.style.opacity = "0.85";
                    house.classList.remove("claimed");
                });
                rotations.A = 0;
                rotations.B = 0;
                rotations.C = 0;
                document.getElementById("circleA").style.transform = "rotate(0deg)";
                document.getElementById("circleB").style.transform = "rotate(0deg)";
                document.getElementById("circleC").style.transform = "rotate(0deg)";
                currentPlayer = "red";
                awaitingRotation = null;
                timers.red = initialTime;
                timers.green = initialTime;
                timerStarted.red = false;
                timerStarted.green = false;
                gameStarted = false;
                document.getElementById("diceButton").classList.remove("disabled");
                stopTimer();
                rollDice();
                updateTimerDisplay();
                toggleArrows(null);
                document.querySelectorAll(".house").forEach(house => house.remove());
                createHouses();
            });

            document.getElementById("computerToggle").addEventListener("click", function() {
                computerMode = !computerMode;
                this.textContent = `Computer Mode: ${computerMode ? "On" : "Off"}`;
                if (computerMode && currentPlayer === "green" && !awaitingRotation && timers.green > 0) {
                    setTimeout(computerMove, 1000);
                }
            });

            // Initialize game
            rollDice();
            updateTimerDisplay();
            toggleArrows(null);
            createHouses();

            // Handle resize
            window.addEventListener("resize", () => {
                document.querySelectorAll(".house").forEach(house => house.remove());
                createHouses();
            });
        });
    </script>

    <div class="instructions">
        <h2>How to Play Patternism</h2>
        <p>Welcome to Patternism, a strategic game of logic and motion! Two players, Red and Green, compete to form a specific pattern on a circular board with three rotating rings (A: outermost ring, B: middle ring, C: innermost ring). Here‚Äôs how to play:</p>
        <p><strong>1. Setting the Pattern:</strong> Before the game begins, click the dice (üé≤) in the top-right corner to roll and select one of six winning patterns. Once the first move is made, the pattern is locked until the game is reset.</p>
        <p><strong>2. Objective:</strong> Players take turns claiming houses (circles on the board) to form the selected pattern. The patterns are:
            <br>
            <br>1 <img src="pattern1.png" alt="Pattern 1">
            <br>
            <br>2 <img src="pattern2.png" alt="Pattern 2">
            <br>
            <br>3 <img src="pattern3.png" alt="Pattern 3">
            <br>
            <br>4 <img src="pattern4.png" alt="Pattern 4">
            <br>
            <br>5 <img src="pattern5.png" alt="Pattern 5">
            <br>
            <br>6 <img src="pattern6.png" alt="Pattern 6">
            <br>
            <br>The first player to complete the pattern wins!
        </p>
        <p><strong>3. Taking Turns:</strong> Red starts. Click an unclaimed house to claim it with your color (red or green). Each player has 30 minutes total, tracked by the timers. The current player‚Äôs turn is shown in the status bar.</p>
        <p><strong>4. Claiming Houses:</strong>
            <ul>
                <li>On Ring A: Claim a house, and your turn ends immediately.</li>
                <li>On Ring B or C: Claim a house, then rotate the ring using the arrow buttons (‚¨ÖÔ∏è‚û°Ô∏è for C, ‚¨ÜÔ∏è‚¨áÔ∏è for B). Ring B rotates both B and C together.</li>
            </ul>
        </p>
        <p><strong>5. Rotating Rings:</strong> After claiming a house on B or C, use the enabled arrows to rotate the ring(s) by fixed increments (20¬∞ for left/right arrows, 40¬∞ for up/down arrows). This aligns pieces toward the target pattern. Only the current player can rotate.</p>
        <p><strong>6. Winning:</strong> The game checks for the selected pattern after each move or rotation. If a player forms the pattern, they win, and the game ends. Detecting the winning position is the responsibility of the player. The game continues until a player finds the pattern. It is possible that you have made the pattern but because you did not see it, the game resumes and your opponent may win. If a timer runs out, the other player wins.</p>
        <p><strong>7. Computer Mode:</strong> Toggle "Computer Mode" to play against an AI as Green. The computer makes strategic moves and rotations toward the selected pattern.</p>
        <p><strong>8. Resetting:</strong> Click "Reset Game" to start over, clearing the board, resetting timers, and allowing a new pattern roll.</p>
        <p>Enjoy the challenge of aligning your pieces while thwarting your opponent. Good luck!</p>
    </div>
</body>
</html>
